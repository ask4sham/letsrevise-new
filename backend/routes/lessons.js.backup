const express = require('express');
const router = express.Router();
const Lesson = require('../models/Lesson');
const User = require('../models/User');
const Purchase = require('../models/Purchase');
const auth = require('../middleware/auth');

// Test endpoint (no auth required)
router.get('/test', (req, res) => {
  res.json({ message: 'Lessons API is working!' });
});

// @route   POST api/lessons
// @desc    Create a lesson
// @access  Private (Teachers only)
router.post('/', auth, async (req, res) => {
  try {
    console.log('Lesson creation attempt for user:', req.user.email);
    console.log('Request body:', req.body);
    
    // Check if user is a teacher
    if (req.user.userType !== 'teacher') {
      return res.status(403).json({ msg: 'Only teachers can create lessons' });
    }

    const {
      title,
      description,
      content,
      subject,
      level,
      topic,
      tags,
      estimatedDuration,
      shamCoinPrice,
      resources
    } = req.body;

    // Basic validation
    if (!title || !description || !content || !subject || !level || !topic || !estimatedDuration) {
      return res.status(400).json({ 
        msg: 'Please fill in all required fields',
        missing: {
          title: !title,
          description: !description,
          content: !content,
          subject: !subject,
          level: !level,
          topic: !topic,
          estimatedDuration: !estimatedDuration
        }
      });
    }

    const lesson = new Lesson({
      title,
      description,
      content,
      teacherId: req.user._id,
      teacherName: `${req.user.firstName} ${req.user.lastName}`,
      subject,
      level,
      topic,
      tags: tags || [],
      estimatedDuration,
      shamCoinPrice: shamCoinPrice || 0,
      resources: resources || [],
      isPublished: false
    });

    console.log('Attempting to save lesson...');
    await lesson.save();
    console.log('Lesson saved successfully:', lesson._id);
    
    // Award ShamCoins for creating a lesson
    req.user.shamCoins = (req.user.shamCoins || 0) + 50;
    await req.user.save();

    res.json({
      msg: 'Lesson created successfully! You earned 50 ShamCoins!',
      lesson,
      updatedShamCoins: req.user.shamCoins
    });

  } catch (err) {
    console.error('âŒ Lesson creation error details:');
    console.error('Error message:', err.message);
    console.error('Error stack:', err.stack);
    console.error('Full error object:', err);
    console.error('User object:', req.user ? { 
      id: req.user._id, 
      email: req.user.email,
      userType: req.user.userType,
      hasShamCoins: req.user.shamCoins !== undefined
    } : 'No user');
    
    res.status(500).json({ 
      error: 'Server error', 
      message: err.message,
      details: process.env.NODE_ENV === 'development' ? err.stack : undefined
    });
  }
});

// @route   GET api/lessons/teacher
// @desc    Get all lessons by a teacher WITH PURCHASE STATS
// @access  Private (Teachers only)
router.get('/teacher', auth, async (req, res) => {
  try {
    if (req.user.userType !== 'teacher') {
      return res.status(403).json({ msg: 'Only teachers can view their lessons' });
    }

    const lessons = await Lesson.find({ teacherId: req.user._id })
      .sort({ createdAt: -1 });

    // Get purchase stats for each lesson
    const lessonsWithStats = await Promise.all(lessons.map(async (lesson) => {
      const lessonObj = lesson.toObject();
      
      // Get purchase count for this lesson
      const purchaseCount = await Purchase.countDocuments({ lessonId: lesson._id });
      lessonObj.purchaseCount = purchaseCount;
      
      // Get total earnings for this lesson
      const purchases = await Purchase.find({ lessonId: lesson._id });
      const totalEarnings = purchases.reduce((sum, purchase) => sum + purchase.teacherEarnings, 0);
      lessonObj.totalEarnings = totalEarnings;
      
      return lessonObj;
    }));

    res.json(lessonsWithStats);
  } catch (err) {
    console.error('Error fetching teacher lessons:', err);
    res.status(500).json({ msg: 'Server error', error: err.message });
  }
});

// @route   GET api/lessons/teacher/stats
// @desc    Get teacher dashboard statistics
// @access  Private (Teachers only)
router.get('/teacher/stats', auth, async (req, res) => {
  try {
    if (req.user.userType !== 'teacher') {
      return res.status(403).json({ msg: 'Only teachers can view stats' });
    }

    const teacherId = req.user._id;
    
    // Get all lessons by this teacher
    const lessons = await Lesson.find({ teacherId });
    
    // Calculate basic stats
    const stats = {
      totalLessons: lessons.length,
      publishedLessons: lessons.filter(l => l.isPublished === true).length,
      draftLessons: lessons.filter(l => l.isPublished === false).length,
      totalEarnings: 0,
      totalPurchases: 0,
      averageRating: 0,
      monthlyEarnings: []
    };
    
    // Get all purchases for this teacher's lessons
    const purchases = await Purchase.find({ teacherId: teacherId });
    
    // Calculate earnings and purchases
    stats.totalPurchases = purchases.length;
    stats.totalEarnings = purchases.reduce((sum, purchase) => sum + (purchase.teacherEarnings || 0), 0);
    
    // Calculate average rating
    const publishedLessons = lessons.filter(l => l.isPublished === true);
    if (publishedLessons.length > 0) {
      const totalRating = publishedLessons.reduce((sum, lesson) => sum + (lesson.averageRating || 0), 0);
      stats.averageRating = totalRating / publishedLessons.length;
    }
    
    // Calculate monthly earnings (last 6 months)
    const sixMonthsAgo = new Date();
    sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
    
    const recentPurchases = purchases.filter(p => p.timestamp >= sixMonthsAgo);
    
    // Group by month
    const monthlyData = {};
    recentPurchases.forEach(purchase => {
      const month = purchase.timestamp.toISOString().slice(0, 7); // YYYY-MM format
      monthlyData[month] = (monthlyData[month] || 0) + (purchase.teacherEarnings || 0);
    });
    
    // Convert to array format
    stats.monthlyEarnings = Object.entries(monthlyData)
      .map(([month, earnings]) => ({
        month: new Date(month + '-01').toLocaleString('default', { month: 'short' }),
        earnings
      }))
      .sort((a, b) => {
        // Sort by month
        const dateA = new Date(a.month + ' 1');
        const dateB = new Date(b.month + ' 1');
        return dateA - dateB;
      });

    res.json(stats);
  } catch (err) {
    console.error('Error fetching teacher stats:', err);
    res.status(500).json({ msg: 'Server error', error: err.message });
  }
});

// @route   GET api/lessons/:id
// @desc    Get lesson by ID
// @access  Private
router.get('/:id', auth, async (req, res) => {
  try {
    const lesson = await Lesson.findById(req.params.id);
    
    if (!lesson) {
      return res.status(404).json({ msg: 'Lesson not found' });
    }

    // Increment views
    lesson.views += 1;
    await lesson.save();

    res.json(lesson);
  } catch (err) {
    console.error(err.message);
    if (err.kind === 'ObjectId') {
      return res.status(404).json({ msg: 'Lesson not found' });
    }
    res.status(500).send('Server error');
  }
});

// @route   PUT api/lessons/:id
// @desc    Update a lesson
// @access  Private (Teacher only)
router.put('/:id', auth, async (req, res) => {
  try {
    const lesson = await Lesson.findById(req.params.id);
    
    if (!lesson) {
      return res.status(404).json({ msg: 'Lesson not found' });
    }

    // Check if user is the teacher who created the lesson
    if (lesson.teacherId.toString() !== req.user._id.toString()) {
      return res.status(401).json({ msg: 'User not authorized' });
    }

    const updates = req.body;
    Object.keys(updates).forEach(key => {
      lesson[key] = updates[key];
    });

    await lesson.save();
    res.json({ msg: 'Lesson updated successfully', lesson });
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Server error');
  }
});

// @route   DELETE api/lessons/:id
// @desc    Delete a lesson
// @access  Private (Teacher only)
router.delete('/:id', auth, async (req, res) => {
  try {
    const lesson = await Lesson.findById(req.params.id);
    
    if (!lesson) {
      return res.status(404).json({ msg: 'Lesson not found' });
    }

    // Check if user is the teacher who created the lesson
    if (lesson.teacherId.toString() !== req.user._id.toString()) {
      return res.status(401).json({ msg: 'User not authorized' });
    }

    await lesson.deleteOne();
    res.json({ msg: 'Lesson removed' });
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Server error');
  }
});

// @route   PUT api/lessons/:id/publish
// @desc    Publish a lesson
// @access  Private (Teacher only)
router.put('/:id/publish', auth, async (req, res) => {
  try {
    const lesson = await Lesson.findById(req.params.id);
    
    if (!lesson) {
      return res.status(404).json({ msg: 'Lesson not found' });
    }

    if (lesson.teacherId.toString() !== req.user._id.toString()) {
      return res.status(401).json({ msg: 'User not authorized' });
    }

    lesson.isPublished = true;
    await lesson.save();

    res.json({ msg: 'Lesson published successfully', lesson });
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Server error');
  }
});

// @route   POST api/lessons/:id/purchase
// @desc    Purchase a lesson
// @access  Private (Students only)
router.post('/:id/purchase', auth, async (req, res) => {
  try {
    console.log('Purchase attempt for lesson:', req.params.id);
    console.log('User attempting purchase:', req.user.email);
    
    // Check if user is a student
    if (req.user.userType !== 'student') {
      return res.status(403).json({ msg: 'Only students can purchase lessons' });
    }

    const lesson = await Lesson.findById(req.params.id);
    
    if (!lesson) {
      return res.status(404).json({ msg: 'Lesson not found' });
    }

    if (!lesson.isPublished) {
      return res.status(400).json({ msg: 'Lesson is not published' });
    }

    // Get user with fresh data from database
    const user = await User.findById(req.user.id);
    
    // Check if already purchased
    const alreadyPurchased = user.purchasedLessons?.some(
      purchase => purchase.lessonId.toString() === lesson._id.toString()
    );
    
    if (alreadyPurchased) {
      return res.status(400).json({ 
        msg: 'You have already purchased this lesson',
        purchasedAt: user.purchasedLessons.find(
          p => p.lessonId.toString() === lesson._id.toString()
        ).purchasedAt
      });
    }

    // Check if student has enough ShamCoins
    const studentShamCoins = user.shamCoins || 0;
    if (studentShamCoins < lesson.shamCoinPrice) {
      return res.status(400).json({ 
        msg: 'Insufficient ShamCoins', 
        required: lesson.shamCoinPrice,
        available: studentShamCoins
      });
    }

    // Deduct ShamCoins from student
    user.shamCoins -= lesson.shamCoinPrice;
    
    // Add lesson to student's purchased lessons
    const purchaseRecord = {
      lessonId: lesson._id,
      price: lesson.shamCoinPrice,
      purchasedAt: new Date()
    };
    
    user.purchasedLessons = user.purchasedLessons || [];
    user.purchasedLessons.push(purchaseRecord);
    
    // Calculate teacher earnings (70% of price)
    const teacherEarnings = Math.floor(lesson.shamCoinPrice * 0.7);
    
    // Award ShamCoins AND earnings to teacher (70% of price)
    const teacher = await User.findById(lesson.teacherId);
    if (teacher) {
      // Add to shamCoins (spendable currency)
      teacher.shamCoins = (teacher.shamCoins || 0) + teacherEarnings;
      
      // ALSO add to earnings field (track total earnings for cash out)
      teacher.earnings = (teacher.earnings || 0) + teacherEarnings;
      
      // Record transaction
      teacher.transactions = teacher.transactions || [];
      teacher.transactions.push({
        type: 'sale',
        amount: teacherEarnings,
        date: new Date(),
        description: `Lesson sale: ${lesson.title}`,
        lessonId: lesson._id,
        status: 'completed'
      });
      
      await teacher.save();
      console.log(`Awarded ${teacherEarnings} ShamCoins and earnings to teacher ${teacher.email}`);
      
      // Send notification to teacher about sale
      const { createNotification } = require('./notifications');
      await createNotification(
        teacher._id,
        'purchase_success',
        'Lesson Sold!',
        `A student purchased your lesson "${lesson.title}" for ${lesson.shamCoinPrice} ShamCoins`,
        {
          lessonId: lesson._id,
          price: lesson.shamCoinPrice,
          earnings: teacherEarnings
        },
        `/lesson/${lesson._id}`
      );
    }

    // Create purchase record in Purchase collection
    const purchase = new Purchase({
      lessonId: lesson._id,
      studentId: user._id,
      teacherId: lesson.teacherId,
      price: lesson.shamCoinPrice,
      teacherEarnings: teacherEarnings,
      timestamp: new Date()
    });
    
    await purchase.save();
    await user.save();

    res.json({
      success: true,
      msg: 'Lesson purchased successfully!',
      lesson: {
        id: lesson._id,
        title: lesson.title,
        price: lesson.shamCoinPrice
      },
      user: {
        _id: user._id,
        id: user._id,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
        userType: user.userType,
        shamCoins: user.shamCoins,
        purchasedLessons: user.purchasedLessons
      },
      remainingShamCoins: user.shamCoins,
      teacherEarned: teacherEarnings,
      purchaseRecord: purchaseRecord
    });

  } catch (err) {
    console.error('Purchase error:', err);
    res.status(500).json({ 
      success: false,
      error: 'Server error', 
      details: err.message 
    });
  }
});

// @route   GET api/lessons
// @desc    Get all published lessons (for students)
// @access  Private
router.get('/', auth, async (req, res) => {
  try {
    const { subject, level, topic, teacher } = req.query;
    let query = { isPublished: true };

    if (subject) query.subject = subject;
    if (level) query.level = level;
    if (topic) query.topic = { $regex: topic, $options: 'i' };
    if (teacher) query.teacherName = { $regex: teacher, $options: 'i' };

    const lessons = await Lesson.find(query)
      .sort({ createdAt: -1 })
      .limit(50);

    res.json(lessons);
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Server error');
  }
});

module.exports = router;
